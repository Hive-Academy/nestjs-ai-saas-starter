name: TypeScript Validation

on:
  push:
    branches: [ main, develop ]
    paths:
      - 'libs/**/*.ts'
      - 'libs/**/tsconfig*.json'
      - 'libs/**/project.json'
      - 'tsconfig*.json'
      - 'eslint.config.mjs'
      - 'package.json'
      - '.github/workflows/typescript-validation.yml'
  pull_request:
    branches: [ main, develop ]
    paths:
      - 'libs/**/*.ts'
      - 'libs/**/tsconfig*.json'
      - 'libs/**/project.json'
      - 'tsconfig*.json'
      - 'eslint.config.mjs'
      - 'package.json'
      - '.github/workflows/typescript-validation.yml'

jobs:
  typescript-validation:
    runs-on: ubuntu-latest

    strategy:
      matrix:
        node-version: [18.x, 20.x]

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Setup Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v4
      with:
        node-version: ${{ matrix.node-version }}
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Cache TypeScript build info
      uses: actions/cache@v4
      with:
        path: |
          libs/**/tsconfig.tsbuildinfo
          libs/**/.tsbuildinfo
        key: ${{ runner.os }}-typescript-${{ hashFiles('**/tsconfig*.json') }}
        restore-keys: |
          ${{ runner.os }}-typescript-

    - name: Run TypeScript compilation check
      run: npm run validate:types:typescript

    - name: Run ESLint validation
      run: npm run validate:types:eslint

    - name: Check for 'any' types
      run: npm run validate:types:any

    - name: Run build validation
      run: npm run validate:types:build

    - name: Run comprehensive CI validation
      run: npm run ci:validate

    - name: Upload validation report
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: typescript-validation-report-node-${{ matrix.node-version }}
        path: |
          typescript-validation-report.json
          ci-validation-report.json
        retention-days: 30

    - name: Comment PR with validation results
      if: github.event_name == 'pull_request' && always()
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');

          // Read validation report
          let report = {};
          try {
            const reportData = fs.readFileSync('ci-validation-report.json', 'utf8');
            report = JSON.parse(reportData);
          } catch (error) {
            console.log('Could not read validation report:', error.message);
            return;
          }

          // Create comment body
          const { summary, results } = report;
          const passed = summary.passed;
          const failed = summary.failed;
          const warnings = summary.warnings;

          let commentBody = `## üîç TypeScript Validation Results (Node.js ${{ matrix.node-version }})\n\n`;

          if (failed === 0) {
            commentBody += `‚úÖ **All validations passed!**\n\n`;
          } else {
            commentBody += `‚ùå **${failed} validation(s) failed**\n\n`;
          }

          commentBody += `üìä **Summary:**\n`;
          commentBody += `- ‚úÖ Passed: ${passed}/${summary.total} libraries\n`;
          commentBody += `- ‚ùå Failed: ${failed}/${summary.total} libraries\n`;
          commentBody += `- ‚ö†Ô∏è Warnings: ${warnings}\n\n`;

          // Add failed libraries details
          if (failed > 0) {
            commentBody += `### ‚ùå Failed Libraries:\n\n`;
            results.filter(r => !r.passed).forEach(result => {
              commentBody += `**${result.library}:**\n`;
              result.errors.forEach(error => {
                commentBody += `- ${error}\n`;
              });
              commentBody += `\n`;
            });
          }

          // Add type coverage metrics
          commentBody += `### üìà Type Coverage:\n\n`;
          results.forEach(result => {
            if (result.metrics.typeCoverage?.success) {
              const coverage = result.metrics.typeCoverage.coverage.toFixed(1);
              const emoji = coverage >= 95 ? '‚úÖ' : '‚ö†Ô∏è';
              commentBody += `${emoji} **${result.library}:** ${coverage}%\n`;
            }
          });

          // Find existing comment
          const { data: comments } = await github.rest.issues.listComments({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number,
          });

          const existingComment = comments.find(comment =>
            comment.user.type === 'Bot' &&
            comment.body.includes('TypeScript Validation Results') &&
            comment.body.includes(`Node.js ${{ matrix.node-version }}`)
          );

          if (existingComment) {
            // Update existing comment
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: existingComment.id,
              body: commentBody
            });
          } else {
            // Create new comment
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: commentBody
            });
          }

  type-coverage-check:
    runs-on: ubuntu-latest
    needs: typescript-validation
    if: github.event_name == 'pull_request'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20.x'
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Download validation report
      uses: actions/download-artifact@v4
      with:
        name: typescript-validation-report-node-20.x

    - name: Check type coverage regression
      run: |
        # This would compare current type coverage with main branch
        # For now, just ensure minimum coverage is met
        node -e "
          const fs = require('fs');
          const report = JSON.parse(fs.readFileSync('ci-validation-report.json', 'utf8'));
          const failedCoverage = report.results.filter(r =>
            r.metrics.typeCoverage?.success &&
            r.metrics.typeCoverage.coverage < 95
          );

          if (failedCoverage.length > 0) {
            console.log('‚ùå Libraries below 95% type coverage:');
            failedCoverage.forEach(lib => {
              console.log(\`  - \${lib.library}: \${lib.metrics.typeCoverage.coverage.toFixed(1)}%\`);
            });
            process.exit(1);
          } else {
            console.log('‚úÖ All libraries meet type coverage requirements');
          }
        "

  quality-gate:
    runs-on: ubuntu-latest
    needs: [typescript-validation, type-coverage-check]
    if: always()

    steps:
    - name: Check quality gate
      run: |
        if [[ "${{ needs.typescript-validation.result }}" == "success" && "${{ needs.type-coverage-check.result }}" == "success" ]]; then
          echo "‚úÖ Quality gate passed"
          exit 0
        else
          echo "‚ùå Quality gate failed"
          echo "TypeScript validation: ${{ needs.typescript-validation.result }}"
          echo "Type coverage check: ${{ needs.type-coverage-check.result }}"
          exit 1
        fi
